\documentclass[a4paper, 10pt, ngerman]{article}
\usepackage{tikz-network}
\usepackage[left=3.5cm, right = 3.5cm, top=3.5cm, bottom=3.5cm, head=13.6pt]{geometry}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage{inputenc}
\usepackage[noend,nosemicolon,algoruled,noline]{algorithm2e}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[nottoc,notlot,notlof]{tocbibind}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{color}
\usepackage{booktabs}
\usepackage{hyperref}

\newcommand{\Aufgabe}{Aufgabe 1: Weniger krumme Touren}
\newcommand{\TeilnahmeId}{67571}
\newcommand{\Name}{Finn Rudolph}

\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\textrm}
\rohead{Teilnahme-ID: \TeilnahmeId}
\lohead{\Aufgabe}
\cfoot*{\thepage{}}

\title{\LARGE \textbf{\Aufgabe}}
\author{\large Finn Rudolph \\ \\ \large Teilnahme-ID: 67571}
\date{\large 11. Februar 2022}

\setlist[enumerate]{label*={\arabic*.}}

\definecolor{keyword}{rgb}{0.2, 0.0, 0.7}
\definecolor{comment}{rgb}{0.5, 0.5, 0.5}
\definecolor{number}{rgb}{0.5, 0.5, 0.5}
\definecolor{string}{rgb}{0.3, 0.65, 0.0}

\lstset
{
    basicstyle=\footnotesize\ttfamily,
    keywordstyle=\color{keyword},
    commentstyle=\color{comment},
    numberstyle=\tiny\color{number},
    stringstyle=\color{string},
    numbers=left,
    showspaces=false,
    showstringspaces=false
}

\hypersetup
{
    colorlinks=true, 
    urlcolor=blue, 
    linkcolor=black, 
    citecolor=black, 
    pdftitle={Aufgabe 1: Weniger krumme Touren}
}

\begin{document}

\begin{titlepage}
    \maketitle
    \tableofcontents
    \thispagestyle{empty}
\end{titlepage}

\newtheorem{theorem}{Satz}
\newtheorem{lemma}{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\section{Lösungsidee}

Das Problem wird durch einen Graphen modelliert. Jeder Punkt wird einem Knoten zugeordnet und zwischen jedem Knotenpaar existiert eine ungerichtete Kante, deren Gewicht die euklidsche Distanz zwischen den zugehörigen Punkten ist. Das Ziel ist es, einen möglichst kurzen Hamiltonpfad durch diesen Graphen zu finden. Die Bedingung, dass kein Abbiegewinkel von mehr als 90° vorkommen darf, bedeutet, dass bestimmte Tripel an Knoten nicht direkt aufeinander folgen dürfen. Das Problem soll nun als ganzzahliges lineares Programm formuliert werden und mithilfe eines IP-Solvers gelöst werden.

Im Folgenden wird mit $d_{ij}$ die Distanz zwischen Punkt $i$ und Punkt $j$, für $0 \le i, j \le n - 1$ bezeichnet, wobei $n$ die Anzahl an Punkten ist. Daneben bezeichnet $\vec{z_i}$ den zweidimensionalen Ortsvektor zu Punkt $i$. $\vec{z_{ij}}$ bezeichnet den Vektor $\vec{z_j} - \vec{z_i}$. Der beschriebene Graph heißt $G = (V, E)$, mit Knotenmenge $V$ und Kantenmenge $E$. Für die IP-Formulierung definieren wir die binären Variablen $x_{ij}$ für $0 \le i, j \le n - 1, i < j$, sodass $x_{ij} = 1$, wenn die Kante zwischen Punkt $i$ und Punkt $j$ in der optimalen Lösung verwendet wird, andernfalls $x_{ij} = 0$. Die Einschränkung $i < j$ ist sinnvoll, um die Anzahl nötiger Variablen zu halbieren. Im Folgenden wird der Einfachheit halber manchmal $x_{ij}$ auch für $i > j$ geschrieben, gemeint ist dann immer $x_{ji}$. Das ganzzahlige lineare Programm sieht wie folgt aus.

\begin{align*}
    \text{minimiere} \quad & \sum_{i = 0}^{n - 1} \sum_{j = i + 1}^{n - 1} x_{ij} d_{ij} & & \quad (1) \\
    \text{sodass} \quad 
    & \sum_{j = 0, j \ne i}^{n - 1} x_{ij} \ge 1 & 0 \le i \le n - 1 & \quad (2) \\
    & \sum_{j = 0, j \ne i}^{n - 1} x_{ij} \le 2 & 0 \le i \le n - 1 & \quad (3) \\
    & \sum_{i = 0}^{n - 1} \sum_{j = i + 1}^{n - 1} x_{ij} = n - 1 & & \quad (4) \\
    & \sum_{i \in S} \sum_{j \in S, i < j} x_{ij} \le |S| - 1 & S \subseteq V, S \ne \emptyset & \quad (5) \\
    & x_{ij} + x_{jk} \le 1 & 0 \le i, j, k \le n - 1, i \ne j \ne k, i < k, \vec{z_{ij}} \cdot \vec{z_{jk}} < 0 & \quad (6) \\
    & x_{ij} \in \{0, 1\} & 0 \le i, j \le n - 1, i < j & \quad (7)
\end{align*}
\smallskip

Ungleichungen (2) und (3) beschränkt den Grad jedes Knoten auf 1 oder 2. Gleichung (4) sorgt dafür, dass insgesamt $n - 1$ Kanten verwendet werden. Ungleichung (5) ist der \emph{Subtour Elimination Constraint (SEC)} in der Formulierung von Dantzig, Fulkerson und Johnson \cite{tsp-formulations}, durch den die Konnektivität des Pfads sichergestellt wird. Ungleichung (6) setzt die Einschränkung des Abbiegewinkels um, wobei $\cdot$ das Skalarprodukt bezeichnet. Es wird nun gezeigt, wie die einzelnen Teile ihr Aufgabe jeweils erfüllen. 

Wir nennen einen Hamiltonpfad mit Abbiegewinkeln kleiner gleich $\pi / 2$ auch einen \emph{zulässigen Pfad}. Damit von dem linearen Programm der kürzeste zulässige Pfad gefunden wird, muss die Menge zulässiger Pfade genau mit der Menge an Pfaden, die durch Gleichungen (2) - (7) erlaubt sind, übereinstimmen. Denn dann wird durch die Zielfunktion in (1) der kürzeste von ihnen gewählt. Zunächst wird gezeigt, dass jeder Pfad, der die Gleichungen (2) - (7) erfüllt, zulässig ist. Dafür sei $X = \{\{i, j\} : x_{ij} = 1\}$ die Menge an Kanten in der Lösung des ganzzahligen linearen Programms.

\begin{lemma}
    Der Graph $G' = (V, X)$ enthält keine Zyklen.
\end{lemma}

\begin{proof}
    Für einen Widerspruch nehme man an, dass sich ein Zyklus in $G'$ befindet, der genau die Knoten der Menge $T$ enthält. Dann gilt
    \begin{align*}
        \sum_{i \in T} \sum_{j \in T, i < j} x_{ij} \ge |T|
    \end{align*}
    da ein Zyklus aus $|T|$ Knoten genau $|T|$ Kanten enthält. Das ist ein Widerspruch zu (5) mit $S = T$, folglich war die Annahme, dass $G'$ einen Zyklus enthält, falsch.
\end{proof}

\begin{lemma}
    Die Kanten in $X$ bilden einen Hamiltonpfad in $G$.
\end{lemma}

\begin{proof}
    Wegen (4) enthält $G' = (V, X)$ genau $n - 1$ Kanten und wegen Lemma 1 ist $G'$ azyklisch. Ein azyklischer Graph mit $n - 1$ Kanten ist ein Baum mit $n$ Knoten, und damit ist $G'$ ein Spannbaum von $G$. Da der Grad jedes Knoten von (3) auf maximal 2 begrenzt wird, hat $G'$ genau zwei Blätter. Wählt man diese beiden Blätter als Endpunkte eines Pfads in $G$, erhält man einen Hamiltonpfad.
\end{proof}
 
Ungleichung (1) ist zur Sicherstellung der gewünschten Eigenschaften von $X$ nicht nötig, verkürzte jedoch praktisch die Laufzeit, weshalb sie mit aufgeführt ist.

\begin{lemma}
    Jeder Abbiegewinkel zwischen zwei aneinanderliegenden Kanten in $X$ ist kleiner oder gleich $\pi / 2$.
\end{lemma}

\begin{proof}
    Der Abbiegewinkel $\alpha$ zweier Vektoren $\vec{u}$ und $\vec{v}$ ist der Betrag des Außenwinkels $\gamma$ zwischen ihnen. Der Außenwinkel ist mit dem Skalarprodukt durch folgende Identität verknüpft.
    \begin{align*}
        \cos(\gamma) = \frac {\vec{u} \cdot \vec{v}} {|\vec{u}||\vec{v}|}
    \end{align*}
    Da $|\gamma| \le \pi / 2 \Longleftrightarrow \cos(\gamma) \ge 0$ und $|\vec{u}| |\vec{v}| \ge 0$, ist $|\gamma| \le \pi / 2$ äquivalent zu $\vec{u} \cdot \vec{v} \ge 0$. Für einen Widerspruch nehme man an, dass der Betrag des Außenwinkels zwischen zwei unterschiedlichen Kanten $\{i, j\} \in X$ und $\{j, k\} \in X$ größer als $\pi / 2$ ist. Da die Kanten unterschiedlich sind, gilt $i \ne j \ne k$. Es wird außerdem angenommen, dass $i < k$, was durch Tauschen von $i$ und $k$ immer erreicht werden kann. Dann gilt $x_{ij} + x_{jk} = 2$ und $\vec{z_{ij}} \cdot \vec{z_{jk}} < 0$, ein Widerspruch zu (6). 
\end{proof}

Die Einschränkung $i < k$ in Ungleichung (6) ist nicht notwendig, sie könnte auch durch $i \ne k$ ersetzt werden, wodurch jedoch Dopplungen entstehen würden. Nun gilt es noch, zu zeigen, dass jeder zulässige Pfad (2) - (7) erfüllt. (7) muss gelten, da eine Kante entweder im Pfad enthalten oder nicht enthalten ist.

\begin{lemma}
    Jeder zulässige Pfad erfüllt die Gleichungen bzw. Ungleichungen (2) - (4).
\end{lemma}

\begin{proof}
    In einem Hamiltonpfad muss jeder Knoten mindestens eine angrenzende Kante haben, da der Pfad sonst nicht jeden Knoten besuchen würde. Außerdem kann kein Knoten mehr als zwei angrenzende Kanten haben, da in einem Hamiltonpfad kein Knoten zweimal besucht wird. Gleichung (4) ist erfüllt, da ein Hamiltonpfad aus $n$ Knoten besteht, und ein einfacher Pfad mit $n$ Knoten $n - 1$ Kanten besitzt.
\end{proof}

\begin{lemma}
    Jeder zulässige Pfad erfüllt Ungleichung (5).
\end{lemma}

\begin{proof}
    Wäre Ungleichung (5) nicht erfüllt, könnte man eine Menge an Knoten $T$ wählen, zwischen denen mindestens $|T|$ Kanten des Pfades verlaufen. Dadurch wird zwingend ein Zyklus in $T$ geschaffen, ein Widerspruch dazu, dass die betrachteten Kanten Teil eines Hamiltonpfades sind.
\end{proof}

\begin{lemma}
    Jeder zulässige Pfad erfüllt Ungleichung (6).
\end{lemma}

\begin{proof}
    Wenn Ungleichung (6) nicht erfüllt ist, gibt es drei Knoten $i, j, k$, sodass $i \ne j \ne k$, $i < k$, $\vec{z_{ij}} \cdot \vec{z_{jk}} < 0$ und sowohl $x_{ij} = 1$ als auch $x_{jk} = 1$. Das heißt, sowohl die Kante $\{i, j\}$ als auch die Kante $\{j, k\}$ liegt auf dem Pfad (und $\{i, j\} \ne \{j, k\}$) und das Skalarprodukt ihrer zugehörigen Vektoren ist negativ. Wie in Lemma 3 aber bereits gezeigt wurde, ist ein negatives Skalarprodukt gleichwertig zu einem Abbiegewinkel größer $\pi / 2$, was der Annahme widerspricht, dass der betrachtete Pfad zulässig ist.
\end{proof}

\begin{theorem}
    Die Lösung des ganzzahligen linearen Programms in (1) - (7) ist der kürzeste zulässige Pfad. 
\end{theorem}

\begin{proof}
    Folgt direkt aus Lemma 1 - 6 und der Minimierung der Gesamtlänge durch (1).
\end{proof}

\emph{Anmerkungen.} 
\begin{itemize}
    \item Im Allgemeinen muss das IP in (1) - (7) aber keine Lösung besitzen. Ein Gegenbeispiel ist jedes Dreieck, dass keinen Winkel größer oder gleich $\pi / 2$ besitzt.
    \item Die von (5) gestellten Bedingungen sind meist nicht alle nötig und werden zu Beginn weggelassen. Nach einer optimalen Lösung des IP werden die nötigen Bedingungen zur Eliminierung der Zyklen in der Lösung hinzugefügt. Das wird solange wiederholt, bis in der Lösung keine Zyklen mehr vorhanden sind.
    \item Für jedes ungeordnete Tripel $\{i, j, k\}$ werden von (6) drei Bedingungen hinzugefügt, wenn das Dreieck $ijk$ spitzwinklig ist, andernfalls zwei Bedingungen. Im Fall eines spitzwinkligen Dreiecks könnte man die drei Bedingungen auch durch eine ersetzen, nämlich $x_{ij} + x_{jk} + x_{ki} \le 1$. Obwohl diese Bedingung stärker als die drei einzelnen ist, verschlechterte die Fallunterscheidung die Laufzeit deutlich.
\end{itemize} 

\section{Laufzeitanalyse}

Um die Laufzeit des Ansatzes zu charakterisieren, soll die Größe des IP in Abhängigkeit von $n$, der Anzahl an Knoten analysiert werden.

Für jedes unterschiedliche Paar an Knoten gibt es eine Variable $x_{ij}$, sodass die Anzahl an Variablen $\binom n 2 = n(n - 1) / 2 = \Theta(n^2)$ ist. Von (2) und (3) werden jeweils $n$ Bedingungen in das IP eingefügt. Gleichung (4) trägt eine Bedingung bei. Im schlechtesten Fall wird von Gleichung (5) eine Bedingung für jede nichtleere Teilmenge von $V$ eingefügt, insgesamt also $O(2^n)$. Die genaue Anzahl an Bedingungen von (6) hängt von der gegebenen Instanz ab, ist im schlechtesten Fall aber $O(n^3)$. Insgesamt hat das ganzzahlige lineare Programm in (1) - (7) also $O(2^n)$ Bedingungen.

Da die Lösung eines ganzzahligen linearen Programms NP-schwer ist, ist die Laufzeit im schlechtesten Fall exponentiell in der Anzahl an Variablen $n(n-1)/2$. Die Basis hängt von der Implementierung des IP-Solvers ab.

\section{Implementierung}

Das Programm wird in C++ geschrieben und wurde auf Linux-Systemen getestet. Als IP-Solver wird der Open-Source Solver HiGHS verwendet \cite{highs}. Zum Ausführen des Programms muss dieser installiert werden, eine Anleitung dazu findet sich in der \href{https://ergo-code.github.io/HiGHS/cpp/get-started.html}{Dokumentation von HiGHS}. Zum Kompilieren kann im Order \emph{aufgabe1} einfach \emph{make} im Terminal ausgeführt werden.

Es erweist sich als praktisch, Punkte im zweidimensionalen Raum als komplexe Zahlen \verb|complex<double>| zu repräsentieren, d. h. die $x$-Koordinate entspricht dem Realteil und $y$-Koordinate dem Imaginärteil.

Für HiGHS ist leider noch keine ausführliche Dokumentation verfügbar, daher wird das Wichtigste hier kurz erklärt. Das ganzzahlige lineare Programm wird in ein \verb|HighsModel| geschrieben, das dann an ein Objekt der Klasse \verb|Highs| gegeben wird. \verb|HighsModel| besitzt das Attribut \verb|lp_|, in dem sich alle relevanten Datenstrukturen zur Spezifizierung des IP befinden. Die folgende Beschreibung bezieht sich auf die Attribute von \verb|lp_|. Die Bedingungsmatrix \verb|a_matrix_| ist eine dünnbesetzte Matrix, in der alle Einträge, die nicht 0 sind, in einem einzigen Vektor \verb|a_matrix_.value_| nach Zeile geordnet gespeichert werden. Die Indizes der Einträge stehen in \verb|a_matrix_.index_|. Für jede Zeile steht der Index ihres ersten Eintrags in \verb|a_matrix.value_| in \verb|a_matrix_.start_|. Eine Zeile nimmt immer einen kontinuierlichen Bereich in \verb|a_matrix_.value_| bzw. \verb|a_matrix_.index_| ein. Das heißt, eine neue Zeile wird hinzugefügt, indem ihre Indizes und Koeffizienten an \verb|a_matrix_.index_| und \verb|a_matrix.value_| angefügt werden und anschließend die neue Länge dieser Vektoren an \verb|a_matrix_.start_| angefügt wird. Daneben wird einmal zu Beginn \verb|a_matrix_.start_| auf \verb|{0}| gesetzt. \verb|row_lower_| und \verb|row_upper_| speichern die Unter- und Oberschranke für den Wert jeder Zeile, \verb|col_lower_| und \verb|col_upper_| für jede Spalte. \verb|col_cost_| speichert die Koeffizienten der Kostenfunktion. Der Vektor \verb|integrality_| enthält den Typ jeder Variablen, in diesem IP sind alle Variablen ganzzahlig.

\subsection{edge\_index}

\verb|size_t edge_index(size_t n, size_t i, size_t j)|
\medskip

\noindent Gibt den Index der zur Kante $\{i, j\}$ zugehörigen Variable $x_{ij}$ zurück. Die Variablen $x_{ij}$ für $i < j$ werden lexikographisch nummeriert, das heißt $x_{01}$ hat Index 0, $x_{02}$ Index 1, \dots, $x_{12}$ Index $n - 1$, $x_{23}$ Index $n - 1 + n - 2$ und so weiter. Der Term $\binom n 2 - \binom {n - \min(i, j)} 2$ gibt den Anfang des ,,Blocks'' von $\min(i, j)$ an, und $\max(i, j) - \min(i, j) - 1$ den Index innerhalb des Blocks.

\subsection{dot\_product}
\verb|double dot_product(complex<double> const &a, complex<double> const &b)|
\medskip

\noindent Gibt das Skalarprodukt von $a$ und $b$, als Vektoren interpretiert, zurück. Es entspricht dem Realteil von $a \bar b$, da $a \bar b = a_1 b_1 + a_2 b_2 - a_1 b_2 i + a_2 b_1 i$, wenn $a = a_1 + a_2 i, b = b_1 + b_2 i$.

\subsection{add\_angle\_constraints}
\verb|void add_angle_constraints(| \\
\verb|    HighsModel &model, vector<complex<double>> const &z)|
\medskip

\noindent Fügt die in Gleichung (6) bestimmten Bedingungen zu \verb|model| hinzu. Dazu wird über jeden möglichen Scheitelpunkt ($j$) und alle unterschiedlichen Knotenpaare $i, k$ mit $i \ne j \ne k$ und $i < k$ iteriert. Wenn der Winkel $ijk$ spitz ist, werden die Variablen von $\{i, j\}$ und $\{j, k\}$ zu einer neuen Zeile hinzugefügt und ihre Koeffizienten auf 1 gesetzt. Die Unterschranke für die neue Zeile der Matrix ist 0, die Oberschranke 1.

\subsection{add\_degree\_constraints}
\verb|void add_degree_constraints(HighsModel &model, size_t n)|
\medskip

\noindent Fügt für jeden Knoten $i$ eine Zeile in die Bedingungsmatrix ein, in der die Variablen aller Kanten aufsummiert werden, von denen $i$ ein Endpunkt ist. Der Wert der Zeile wird auf $[1, 2]$ beschränkt, sodass Ungleichungen (2) und (3) umgesetzt werden.

\subsection{add\_num\_edges\_constraint}
\verb|void add_num_edges_constraint(HighsModel &model, size_t n)|
\medskip

\noindent Beschränkt die Anzahl verwendeter Kanten auf genau $n - 1$, indem alle $\binom n 2$ Variablen in einer neuen Zeile aufsummiert werden, und der Wert der Zeile auf $n - 1$ fixiert wird.

\subsection{add\_subtour\_elimination\_constraint}
\verb|void add_subtour_elimination_constraint(| \\
\verb|    Highs &highs, size_t n, vector<size_t> const &tour)|
\medskip

\noindent Fügt für die Knoten in \verb|subtour| einen Subtour Elimination Constraint ein, wie in Ungleichung (5) beschrieben. Da das nach Übergabe des \verb|HighsModel| an das \verb|Highs|-Objekt geschieht, wird die Funktion \verb|Highs::addRow| verwendet. Ihre Parameter sind die Unterschranke und Oberschranke der neuen Zeile, die Anzahl an Einträgen, die nicht 0 sind, und Zeiger zu den Indizes und Werten. Zuerst werden zwei Arrays \verb|ind| und \verb|val| angelegt. Da in der neuen Zeile die Variablen für jede Kante zwischen zwei Knoten in \verb|tour| aufsummiert werden sollen, wird über jedes Paar an Knoten in \verb|tour| iteriert. Der Index der Kante zwischen dem Paar wird in \verb|ind| eingefügt und der Koeffizient in \verb|val| auf 1 gesetzt. Schließlich wird \verb|Highs::addRow| aufgerufen und die Oberschranke der neuen Zeile auf \verb|tour.size() - 1| gesetzt.

\subsection{build\_graph}
\verb|vector<vector<size_t>> build_graph(Highs const &highs, size_t n)|
\medskip

\noindent Gibt den Graphen in Form einer Adjazenzliste zurück, der genau die Kanten aus der in \verb|highs| gespeicherten Lösung enthält. Dazu wird über jedes Knotenpaar $i, j$ mit $i < j$ iteriert, und wenn der Wert der zu $\{i, j\}$ zugehörigen Variable 1 ist, wird die Kante $\{i, j\}$ in den Graphen eingefügt. Da die Variablen in der Lösung nur 0 oder 1 sein können aber aufgrund von Rundungsfehlern möglicherweise nicht exakt 0 oder 1 sind, wird die Bedingung \verb|> 0.5| anstatt \verb|== 1| verwendet.

\subsection{check\_for\_subtours}
\verb|bool check_for_subtours(Highs &highs, size_t n)|
\medskip

\noindent Gibt zurück, ob in der in \verb|highs| enthaltenen Lösung Subtouren existieren und eliminiert dies gegebenenfalls. Es werden alle Zyklen in dem Graphen \verb|graph|, der ausschließlich die Kanten aus der Lösung enthält, gefunden. Von jedem noch nicht besuchten Knoten aus wird eine Suche (ähnlich zur Tiefensuche) durchgeführt und festgestellt, ob der ursprüngliche Knoten \verb|i| wieder erreicht wird. \verb|j| ist der aktuelle Knoten in der Suche, \verb|last| der vorherige. Jeder besuchte Knoten wird als besucht markiert und zu \verb|subtour| hinzugefügt. Der Unterschied zur Tiefensuche ist, dass immer nur ein Nachbar betrachtet wird, was ausreicht, da jeder Knoten maximal Grad 2 hat. Wird \verb|i| wieder erreicht, enthält \verb|subtour| den gesamten Zyklus, von dem \verb|i| Teil ist, und es wird ein Subtour Elimination Constraint für ihn hinzugefügt.

\subsection{get\_optimal\_tour}

\verb|pair<vector<complex<double>>, double> get_optimal_tour(| \\
\verb|    vector<complex<double>> const &z)|
\medskip

\noindent Gibt den kürzesten Hamiltonpfad mit Abbiegewinkeln von maximal $\pi / 2$ als Permutation der in \verb|z| gegebenen Punkte zurück, sowie dessen Länge. Falls keine Lösung existiert, wird ein leerer Vektor zurückgegeben.

Zunächst werden grundsätzliche Eigenschaften des \verb|model| festgelegt, z. B. dass die Zielfunktion minimiert werden soll und die Anzahl an Spalten oder Variablen $\binom n 2$ ist. Darauf wird über jedes Knotenpaar $i, j$ mit $i < j$ iteriert und der Koeffizient der Variable $x_{ij}$ auf $d_{ij}$ gesetzt. Daneben wird festgelegt, dass $x_{ij} \in \{0, 1\}$ sein muss. Anschließend werden die verschiedenen Bedingungen zu \verb|model| hinzugefügt und dessen Anzahl an Zeilen aktualisiert.

Danach wird das Objekt \verb|highs| angelegt und ihm \verb|model| übergeben. Solange Subtouren existieren und nicht festgestellt wurde, dass es keine Lösung gibt (signalisiert durch \verb|HighsModelStatus::kInfeasible|), wird das IP mit \verb|Highs::run()| gelöst und entsprechende SECs eingefügt.

Falls eine Lösung existiert, wird der Graph mit Kanten aus der Lösung mithilfe von \verb|build_graph()| erstellt. Anschließend wird ein Knoten mit Grad 1 als Startpunkt für eine Suche durch den Graphen ausgewählt. Die Suche zum Finden des Hamiltonpfads funktioniert wie in \verb|check_for_subtours|, es wird immer ein aktueller Knoten \verb|j| und dessen Vorgänger \verb|last| verwaltet. Jeder besuchte Knoten wird zum Vektor \verb|tour| hinzugefügt, der am Ende zurückgegeben wird.

\section{Beispiele}

\section{Quellcode}

\begin{thebibliography}{1}
    \bibitem{tsp-formulations}
    Öncan, T., Altinel, I. K., Laporte, G. (2009).
    A comparative analysis of several asymmetric traveling salesman problem formulations. \\
    https://mate.unipv.it/\textasciitilde{}gualandi/famo2conti/papers/tsp\_formulations.pdf
    
    \bibitem{highs}
    Huangfu, Q., Hall, J. A. J. (2018)
    Parallelizing the dual revised simplex method. \\
    https://www.maths.ed.ac.uk/hall/HuHa13/ \\
    https://github.com/ERGO-Code/HiGHS
\end{thebibliography}

\end{document}